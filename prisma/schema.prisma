generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Apprenant {
  id_apprenant     Int            @id @default(autoincrement())
  email            String         @unique
  motDePasse       String
  statut           Statut         @default(EN_ATTENTE)
  dateCreation     DateTime       @default(now())
  dateModification DateTime       @updatedAt
  nom              String
  telephone        String?
  prenom           String
  walletAddress String    @unique // L'adresse du portefeuille blockchain de l'utilisateur
  
  // Relations many-to-many avec les établissements
  liaisons         LiaisonApprenantEtablissement[]
  certificates    Certificate[]   // Les certificats émis par cet établissement
  @@map("apprenants")
}

model Etablissement {
  id_etablissement                  Int                     @id @default(autoincrement())
  nomEtablissement                  String
  emailEtablissement                String                  @unique
  motDePasseEtablissement           String
  rccmEtablissement                 String                  @unique
  typeEtablissement                 TypeEtablissement
  dateCreation                      DateTime                @default(now())
  dateModification                  DateTime                @updatedAt
  adresseEtablissement              String
  telephoneEtablissement            String
  nomResponsableEtablissement       String
  emailResponsableEtablissement     String
  telephoneResponsableEtablissement String
  statut                            Statut                  @default(EN_ATTENTE)
  smartContractAddress  String?   @unique // L'adresse de son contrat sur la blockchain, unique
  
  // Relations many-to-many avec les apprenants
  liaisons                          LiaisonApprenantEtablissement[] // Les inscriptions des étudiants dans cet établissement
  documents                         DocumentEtablissement[] // Les documents justificatifs soumis
  // Relations
  certificates    Certificate[]   // Les certificats émis par cet établissement
  subscriptionPlan SubscriptionPlan? @relation(fields: [subscriptionPlanId], references: [id])
  subscriptionPlanId Int?
  payments        Payment[]       // Les paiements d'abonnement

  @@map("etablissements")
}

model Admin {
  id_admin         Int      @id @default(autoincrement())
  email            String   @unique
  motDePasse       String
  statut           Statut   @default(ACTIF)
  dateCreation     DateTime @default(now())
  dateModification DateTime @updatedAt
  nom              String
  prenom           String

  @@map("admins")
}

model Session {
  id        String   @id @default(cuid())
  userId    Int
  userType  String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("sessions")
}

model DocumentEtablissement {
  id              Int            @id @default(autoincrement())
  etablissementId Int
  typeDocument    String
  nomFichier      String
  typeMime        String
  tailleFichier   Int
  cheminFichier   String?
  statut          StatutDocument @default(EN_ATTENTE)
  dateUpload      DateTime       @default(now())
  dateValidation  DateTime?
  commentaires    String?
  etablissement   Etablissement  @relation(fields: [etablissementId], references: [id_etablissement])

  @@map("documents_etablissement")
}

enum Statut {
  EN_ATTENTE
  ACTIF
  SUSPENDU
  REJETE
}

enum TypeEtablissement {
  UNIVERSITE_PUBLIQUE
  UNIVERSITE_PRIVEE
  INSTITUT_SUPERIEUR
  ECOLE_TECHNIQUE
  CENTRE_FORMATION
  AUTRE
}

enum StatutDocument {
  EN_ATTENTE
  VALIDE
  REJETE
  EXPIRED
}

// Nouveau modèle pour gérer les liaisons many-to-many entre apprenants et établissements
model LiaisonApprenantEtablissement {
  id                Int      @id @default(autoincrement())
  apprenantId       Int
  etablissementId   Int
  statutLiaison     StatutLiaison @default(EN_ATTENTE)
  dateDemande       DateTime @default(now())
  dateApprobation   DateTime?
  dateRejet         DateTime?
  messageDemande    String?
  messageReponse    String?
  approuvePar       Int?     // ID de l'admin qui a approuvé
  
  // Relations
  apprenant         Apprenant @relation(fields: [apprenantId], references: [id_apprenant], onDelete: Cascade)
  etablissement     Etablissement @relation(fields: [etablissementId], references: [id_etablissement], onDelete: Cascade)
  
  @@unique([apprenantId, etablissementId])
  @@map("liaisons_apprenant_etablissement")
}

enum StatutLiaison {
  EN_ATTENTE
  APPROUVE
  REJETE
  SUSPENDU
}

// Représente un certificat numérique émis.
model Certificate {
  id              Int   @id @default(autoincrement())
  title           String
  description     String?  @db.Text
  issueDate       DateTime
  pdfUrl          String   // Lien vers le fichier PDF stocké
  transactionHash String   @unique // Hash de la transaction blockchain
  documentHash    String   @unique // Empreinte SHA-256 du PDF

  status CertificateStatus @default(ISSUED)

  createdAt DateTime @default(now())

  // Relations
  issuer      Etablissement @relation(fields: [issuerId], references: [id_etablissement]) // L'établissement émetteur
  issuerId    Int
  learner     Apprenant        @relation(fields: [learnerId], references: [id_apprenant]) // L'apprenant qui reçoit le certificat
  learnerId   Int @unique

  verificationLogs VerificationLog[] // L'historique des vérifications de ce certificat
}

// ===============================================
//                MODÈLES DE SUPPORT
// ===============================================

model SubscriptionPlan {
  id               Int   @id @default(autoincrement())
  name             String   @unique // ex: "Basic", "Pro"
  pricePerMonth    Decimal
  certificateLimit Int

  institutions Etablissement[]
}

model Payment {
  id            Int   @id @default(autoincrement())
  amount        Decimal
  paymentDate   DateTime @default(now())
  status        PaymentStatus @default(SUCCESS)

  institution   Etablissement @relation(fields: [institutionId], references: [id_etablissement])
  institutionId Int
}

model VerificationLog {
  id               Int   @id @default(autoincrement())
  verificationDate DateTime @default(now())
  ipAddress        String?
  result           Boolean

  certificate   Certificate @relation(fields: [certificateId], references: [id])
  certificateId Int
}


// ===============================================
//                       ENUMS
// ===============================================

enum CertificateStatus {
  ISSUED
  REVOKED
}

enum PaymentStatus {
  SUCCESS
  FAILED
}
