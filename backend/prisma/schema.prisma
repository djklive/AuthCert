generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Apprenant {
  id_apprenant     Int            @id @default(autoincrement())
  email            String         @unique
  motDePasse       String
  statut           Statut         @default(EN_ATTENTE)
  dateCreation     DateTime       @default(now())
  dateModification DateTime       @updatedAt
  nom              String
  telephone        String?
  prenom           String
  walletAddress    String?        @unique
  
  // Relations many-to-many avec les établissements
  liaisons         LiaisonApprenantEtablissement[]
  certificats      Certificat[]
  demandesCertificat DemandeCertificat[]
  
  // Relation avec le coffre-fort des clés privées
  walletVault      WalletVault? @relation("ApprenantWallet")
  
  // Relations avec les sessions
  sessions         Session[] @relation("ApprenantSessions")

  @@map("apprenants")
}

model Etablissement {
  id_etablissement                  Int                     @id @default(autoincrement())
  nomEtablissement                  String
  emailEtablissement                String                  @unique
  motDePasseEtablissement           String
  rccmEtablissement                 String                  @unique
  typeEtablissement                 TypeEtablissement
  dateCreation                      DateTime                @default(now())
  dateModification                  DateTime                @updatedAt
  adresseEtablissement              String
  telephoneEtablissement            String
  nomResponsableEtablissement       String
  emailResponsableEtablissement     String
  telephoneResponsableEtablissement String
  statut                            Statut                  @default(EN_ATTENTE)
  smartContractAddress              String?                 @unique
  
  // Relations many-to-many avec les apprenants
  liaisons                          LiaisonApprenantEtablissement[]
  documents                         DocumentEtablissement[]
  certificats                       Certificat[]
  demandesCertificat                DemandeCertificat[]
  
  // Relation avec le coffre-fort des clés privées
  walletVault                       WalletVault? @relation("EtablissementWallet")
  
  // Relations avec les sessions
  sessions                          Session[] @relation("EtablissementSessions")

  @@map("etablissements")
}

model Admin {
  id_admin         Int      @id @default(autoincrement())
  email            String   @unique
  motDePasse       String
  statut           Statut   @default(ACTIF)
  dateCreation     DateTime @default(now())
  dateModification DateTime @updatedAt
  nom              String
  prenom           String
  
  // Relations avec les sessions
  sessions         Session[] @relation("AdminSessions")

  @@map("admins")
}

model Session {
  id        Int   @id @default(autoincrement())
  userId    Int
  userType  String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Relations optionnelles pour l'intégrité référentielle
  // Note: Une seule relation sera non-null selon userType
  apprenantId     Int?
  etablissementId Int?
  adminId         Int?

  apprenant     Apprenant?     @relation("ApprenantSessions", fields: [apprenantId], references: [id_apprenant], onDelete: Cascade)
  etablissement Etablissement? @relation("EtablissementSessions", fields: [etablissementId], references: [id_etablissement], onDelete: Cascade)
  admin         Admin?         @relation("AdminSessions", fields: [adminId], references: [id_admin], onDelete: Cascade)

  @@map("sessions")
}

model DocumentEtablissement {
  id              Int            @id @default(autoincrement())
  etablissementId Int
  typeDocument    String
  nomFichier      String
  typeMime        String
  tailleFichier   Int
  cheminFichier   String?
  statut          StatutDocument @default(EN_ATTENTE)
  dateUpload      DateTime       @default(now())
  dateValidation  DateTime?
  commentaires    String?
  etablissement   Etablissement  @relation(fields: [etablissementId], references: [id_etablissement])

  @@map("documents_etablissement")
}

// ===============================================
//                CERTIFICATS
// ===============================================

model Certificat {
  id               Int               @id @default(autoincrement())
  uuid             String            @unique
  etablissementId  Int
  apprenantId      Int
  titre            String
  mention          String?
  dateObtention    DateTime
  pdfUrl           String?
  pdfHash          String?
  statut           StatutCertificat  @default(BROUILLON)
  txHash           String?
  contractAddress  String?
  issuedAt         DateTime?
  createdAt        DateTime          @default(now())

  etablissement    Etablissement     @relation(fields: [etablissementId], references: [id_etablissement])
  apprenant        Apprenant         @relation(fields: [apprenantId], references: [id_apprenant])

  @@map("certificats")
}

enum Statut {
  EN_ATTENTE
  ACTIF
  SUSPENDU
  REJETE
}

enum TypeEtablissement {
  UNIVERSITE_PUBLIQUE
  UNIVERSITE_PRIVEE
  INSTITUT_SUPERIEUR
  ECOLE_TECHNIQUE
  CENTRE_FORMATION
  AUTRE
}

enum StatutDocument {
  EN_ATTENTE
  VALIDE
  REJETE
  EXPIRED
}

enum StatutCertificat {
  BROUILLON
  A_EMETTRE
  EMIS
  REVOQUE
}

// Coffre-fort pour stocker les clés privées chiffrées
model WalletVault {
  id         Int      @id @default(autoincrement())
  ownerType  String   // 'apprenant' | 'etablissement'
  ownerId    Int
  iv         String
  authTag    String
  cipherText String
  createdAt  DateTime @default(now())

  // Relations optionnelles pour l'intégrité référentielle
  // Note: Une seule relation sera non-null selon ownerType
  apprenantId     Int? @unique
  etablissementId Int? @unique

  apprenant     Apprenant?     @relation("ApprenantWallet", fields: [apprenantId], references: [id_apprenant], onDelete: Cascade)
  etablissement Etablissement? @relation("EtablissementWallet", fields: [etablissementId], references: [id_etablissement], onDelete: Cascade)

  @@index([ownerType, ownerId])
  @@map("wallet_vault")
}
// Nouveau modèle pour gérer les liaisons many-to-many entre apprenants et établissements
model LiaisonApprenantEtablissement {
  id                Int      @id @default(autoincrement())
  apprenantId       Int
  etablissementId   Int
  statutLiaison     StatutLiaison @default(EN_ATTENTE)
  dateDemande       DateTime @default(now())
  dateApprobation   DateTime?
  dateRejet         DateTime?
  messageDemande    String?
  messageReponse    String?
  approuvePar       Int?     // ID de l'admin qui a approuvé
  
  // Relations
  apprenant         Apprenant @relation(fields: [apprenantId], references: [id_apprenant], onDelete: Cascade)
  etablissement     Etablissement @relation(fields: [etablissementId], references: [id_etablissement], onDelete: Cascade)
  
  @@unique([apprenantId, etablissementId])
  @@map("liaisons_apprenant_etablissement")
}

enum StatutLiaison {
  EN_ATTENTE
  APPROUVE
  REJETE
  SUSPENDU
}

// Nouveau modèle pour les demandes de certificat
model DemandeCertificat {
  id                Int      @id @default(autoincrement())
  apprenantId       Int
  etablissementId   Int
  titre             String
  description       String?
  messageDemande    String?
  statutDemande     StatutDemandeCertificat @default(EN_ATTENTE)
  dateDemande       DateTime @default(now())
  dateTraitement    DateTime?
  messageReponse    String?
  traitePar         Int?     // ID de l'admin qui a traité
  
  // Relations
  apprenant         Apprenant @relation(fields: [apprenantId], references: [id_apprenant], onDelete: Cascade)
  etablissement     Etablissement @relation(fields: [etablissementId], references: [id_etablissement], onDelete: Cascade)
  
  // Documents joints
  documents         DocumentDemandeCertificat[]
  
  @@map("demandes_certificat")
}

model DocumentDemandeCertificat {
  id                Int      @id @default(autoincrement())
  demandeId         Int
  nomFichier        String
  typeMime          String
  tailleFichier     Int
  cheminFichier     String
  dateUpload        DateTime @default(now())
  
  // Relations
  demande           DemandeCertificat @relation(fields: [demandeId], references: [id], onDelete: Cascade)
  
  @@map("documents_demande_certificat")
}

enum StatutDemandeCertificat {
  EN_ATTENTE
  APPROUVE
  REJETE
  EN_COURS_TRAITEMENT
}
